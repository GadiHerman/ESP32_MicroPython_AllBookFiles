"""
ESP32 Micropython NeoPixel 8x32 matrix text display

https://github.com/GadiHerman/ESP32_MicroPython_AllBookFiles

MIT License
Copyright (c) 2025 Gadi Herman

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

from machine import Pin
from neopixel import NeoPixel
from time import sleep

class Matrix:

    # Font definition - each character is defined as 5x7 bitmap
    FONT = [
        [0x00, 0x00, 0x00, 0x00, 0x00],  # 0x20 space
        [0x00, 0x00, 0x5F, 0x00, 0x00],  # 0x21 !
        [0x00, 0x07, 0x00, 0x07, 0x00],  # 0x22 "
        [0x14, 0x7F, 0x14, 0x7F, 0x14],  # 0x23 #
        [0x24, 0x2A, 0x7F, 0x2A, 0x12],  # 0x24 $
        [0x23, 0x13, 0x08, 0x64, 0x62],  # 0x25 %
        [0x36, 0x49, 0x56, 0x20, 0x50],  # 0x26 &
        [0x00, 0x08, 0x07, 0x03, 0x00],  # 0x27 Â´
        [0x00, 0x1C, 0x22, 0x41, 0x00],  # 0x28 (
        [0x00, 0x41, 0x22, 0x1C, 0x00],  # 0x29 )
        [0x2A, 0x1C, 0x7F, 0x1C, 0x2A],  # 0x2A *
        [0x08, 0x08, 0x3E, 0x08, 0x08],  # 0x2B +
        [0x00, 0x80, 0x70, 0x30, 0x00],  # 0x2C ,
        [0x08, 0x08, 0x08, 0x08, 0x08],  # 0x2D -
        [0x00, 0x00, 0x60, 0x60, 0x00],  # 0x2E .
        [0x20, 0x10, 0x08, 0x04, 0x02],  # 0x2F /
        [0x3E, 0x51, 0x49, 0x45, 0x3E],  # 0x30 0
        [0x00, 0x42, 0x7F, 0x40, 0x00],  # 0x31 1
        [0x72, 0x49, 0x49, 0x49, 0x46],  # 0x32 2
        [0x21, 0x41, 0x49, 0x4D, 0x33],  # 0x33 3
        [0x18, 0x14, 0x12, 0x7F, 0x10],  # 0x34 4
        [0x27, 0x45, 0x45, 0x45, 0x39],  # 0x35 5
        [0x3C, 0x4A, 0x49, 0x49, 0x31],  # 0x36 6
        [0x41, 0x21, 0x11, 0x09, 0x07],  # 0x37 7
        [0x36, 0x49, 0x49, 0x49, 0x36],  # 0x38 8
        [0x46, 0x49, 0x49, 0x29, 0x1E],  # 0x39 9
        [0x00, 0x00, 0x14, 0x00, 0x00],  # 0x3A :
        [0x00, 0x40, 0x34, 0x00, 0x00],  # 0x3B ;
        [0x00, 0x08, 0x14, 0x22, 0x41],  # 0x3C <
        [0x14, 0x14, 0x14, 0x14, 0x14],  # 0x3D =
        [0x00, 0x41, 0x22, 0x14, 0x08],  # 0x3E >
        [0x02, 0x01, 0x59, 0x09, 0x06],  # 0x3F ?
        [0x3E, 0x41, 0x5D, 0x59, 0x4E],  # 0x40 @
        [0x7C, 0x12, 0x11, 0x12, 0x7C],  # 0x41 A
        [0x7F, 0x49, 0x49, 0x49, 0x36],  # 0x42 B
        [0x3E, 0x41, 0x41, 0x41, 0x22],  # 0x43 C
        [0x7F, 0x41, 0x41, 0x41, 0x3E],  # 0x44 D
        [0x7F, 0x49, 0x49, 0x49, 0x41],  # 0x45 E
        [0x7F, 0x09, 0x09, 0x09, 0x01],  # 0x46 F
        [0x3E, 0x41, 0x41, 0x51, 0x73],  # 0x47 G
        [0x7F, 0x08, 0x08, 0x08, 0x7F],  # 0x48 H
        [0x00, 0x41, 0x7F, 0x41, 0x00],  # 0x49 I
        [0x20, 0x40, 0x41, 0x3F, 0x01],  # 0x4A J
        [0x7F, 0x08, 0x14, 0x22, 0x41],  # 0x4B K
        [0x7F, 0x40, 0x40, 0x40, 0x40],  # 0x4C L
        [0x7F, 0x02, 0x1C, 0x02, 0x7F],  # 0x4D M
        [0x7F, 0x04, 0x08, 0x10, 0x7F],  # 0x4E N
        [0x3E, 0x41, 0x41, 0x41, 0x3E],  # 0x4F O
        [0x7F, 0x09, 0x09, 0x09, 0x06],  # 0x50 P
        [0x3E, 0x41, 0x51, 0x21, 0x5E],  # 0x51 Q
        [0x7F, 0x09, 0x19, 0x29, 0x46],  # 0x52 R
        [0x26, 0x49, 0x49, 0x49, 0x32],  # 0x53 S
        [0x03, 0x01, 0x7F, 0x01, 0x03],  # 0x54 T
        [0x3F, 0x40, 0x40, 0x40, 0x3F],  # 0x55 U
        [0x1F, 0x20, 0x40, 0x20, 0x1F],  # 0x56 V
        [0x3F, 0x40, 0x38, 0x40, 0x3F],  # 0x57 W
        [0x63, 0x14, 0x08, 0x14, 0x63],  # 0x58 X
        [0x03, 0x04, 0x78, 0x04, 0x03],  # 0x59 Y
        [0x61, 0x59, 0x49, 0x4D, 0x43],  # 0x5A Z
        [0x00, 0x7F, 0x41, 0x41, 0x41],  # 0x5B [
        [0x02, 0x04, 0x08, 0x10, 0x20],  # 0x5C '\'
        [0x00, 0x41, 0x41, 0x41, 0x7F],  # 0x5D ]
        [0x04, 0x02, 0x01, 0x02, 0x04],  # 0x5E ^
        [0x40, 0x40, 0x40, 0x40, 0x40],  # 0x5F _
        [0x00, 0x03, 0x07, 0x08, 0x00],  # 0x60 `
        [0x20, 0x54, 0x54, 0x78, 0x40],  # 0x61 a
        [0x7F, 0x28, 0x44, 0x44, 0x38],  # 0x62 b
        [0x38, 0x44, 0x44, 0x44, 0x00],  # 0x63 c
        [0x38, 0x44, 0x44, 0x28, 0x7F],  # 0x64 d
        [0x38, 0x54, 0x54, 0x54, 0x18],  # 0x65 e
        [0x00, 0x08, 0x7E, 0x09, 0x02],  # 0x66 f
        [0x0C, 0x52, 0x52, 0x4E, 0x3C],  # 0x67 g
        [0x7F, 0x08, 0x04, 0x04, 0x78],  # 0x68 h
        [0x00, 0x44, 0x7D, 0x40, 0x00],  # 0x69 i
        [0x20, 0x40, 0x40, 0x3D, 0x00],  # 0x6A j
        [0x7F, 0x10, 0x28, 0x44, 0x00],  # 0x6B k
        [0x00, 0x41, 0x7F, 0x40, 0x00],  # 0x6C l
        [0x7C, 0x04, 0x78, 0x04, 0x78],  # 0x6D m
        [0x7C, 0x08, 0x04, 0x04, 0x78],  # 0x6E n
        [0x38, 0x44, 0x44, 0x44, 0x38],  # 0x6F o
        [0xFC, 0x18, 0x24, 0x24, 0x18],  # 0x70 p
        [0x0C, 0x12, 0x12, 0x0C, 0x7E],  # 0x71 q
        [0x7C, 0x08, 0x04, 0x04, 0x08],  # 0x72 r
        [0x48, 0x54, 0x54, 0x54, 0x24],  # 0x73 s
        [0x04, 0x04, 0x3F, 0x44, 0x24],  # 0x74 t
        [0x3C, 0x40, 0x40, 0x20, 0x7C],  # 0x75 u
        [0x1C, 0x20, 0x40, 0x20, 0x1C],  # 0x76 v
        [0x3C, 0x40, 0x30, 0x40, 0x3C],  # 0x77 w
        [0x44, 0x28, 0x10, 0x28, 0x44],  # 0x78 x
        [0x0C, 0x10, 0x10, 0x50, 0x3C],  # 0x79 y
        [0x44, 0x64, 0x54, 0x4C, 0x44],  # 0x7A z
        [0x00, 0x08, 0x36, 0x41, 0x00],  # 0x7B {
        [0x00, 0x00, 0x7F, 0x00, 0x00],  # 0x7C |
        [0x00, 0x41, 0x36, 0x08, 0x00],  # 0x7D }
        [0x02, 0x01, 0x02, 0x04, 0x02]   # 0x7E ~
    ]
            
    def __init__(self, pin, width, height, color, CharSpacing=1):
        """
        Initialize Matrix object

        Args:
            pin: The GPIO pin to use
            width: Width of the matrix
            height: Height of the matrix
            color: Default color as [r, g, b]
        """
        self.width = width
        self.height = height
        self.color = color
        self.CharSpacing = CharSpacing
        self.First_Font_index = 0x20
        self.np = NeoPixel(pin, width * height)
        self.clear()

    def clear(self):
        """Clear all pixels (set to black)"""
        for i in range(self.width * self.height):
            self.np[i] = (0, 0, 0)
        self.np.write()

    def set_pixel(self, x, y, color=None):
        """
        Set a pixel at (x, y) to specified color

        Args:
            x: X coordinate (0 to width-1)
            y: Y coordinate (0 to height-1)
            color: Color as [r, g, b], uses default color if None
        """
        if x < 0 or x >= self.width or y < 0 or y >= self.height:
            return  # Out of bounds

        if color is None:
            color = self.color

        index = x * self.height + y
        self.np[index] = tuple(color)

    def show_char(self, char_data, x_offset=0, color=None):
        """
        Display a character at the specified offset

        Args:
            char_data: Character data as 5 bytes (each representing a column)
            x_offset: X position to start from
            color: Color to use, uses default if None
        """
        if color is None:
            color = self.color
        char_map = self.FONT[ord(char_data)-self.First_Font_index]
        # Draw the character (5 columns wide)
        for col in range(5):
            byte = char_map[col]
            for row in range(7):  # Font height is 7
                if byte & (1 << row):  # Check if bit is set
                    # 6-row to flip vertically
                    self.set_pixel(x_offset + col, 6 - row, color)
        self.np.write()

    def show_text(self, text_data, scroll=True, scroll_delay=0.1, color=None):
        """
        Display text on the matrix

        Args:
            text_data: List of character data (each being 5 bytes)
            scroll: Whether to scroll the text
            scroll_delay: Delay between scroll steps
            color: Color to use, uses default if None
        """
        if color is None:
            color = self.color
        
        if not scroll and len(text_data) * (5+ self.CharSpacing) > self.width:
            # Can't fit on screen, force scrolling
            scroll = True

        # Clear the display
        self.clear()

        if not scroll:
            # Static display
            x_offset = 0
            for char_data in text_data:
                self.show_char(char_data, x_offset, color)
                x_offset += 5 + self.CharSpacing  # Char width + space
            self.np.write()
        else:
            # Scrolling display
            # Start with text off the right edge
            total_width = len(text_data) * (5+ self.CharSpacing)

            for offset in range(self.width + total_width):
                self.clear()
                char_offset = 0

                for char_data in text_data:
                    char_pos = self.width - offset + char_offset
                    # Only draw if on screen
                    if char_pos < self.width and char_pos > -4: 
                        self.show_char(char_data, char_pos, color)
                    char_offset += 5  + self.CharSpacing  # Char width + space

                self.np.write()
                sleep(scroll_delay)


# Example usage:
pin = 14
width = 32
height = 8
color1 = [255, 0, 0]
color2 = [0, 255, 0]
color3 = [0, 0, 255]
mat = Matrix(Pin(pin), width, height, color1)
mat.show_text("12:45", scroll=False)
sleep(2)
mat.show_text("HELLO!", scroll=False , color=color2)
sleep(2)
mat.show_text("ABC abc", scroll=True , scroll_delay=0.01 , color=color3)
sleep(2)
mat.clear()
